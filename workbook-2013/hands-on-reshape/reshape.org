#+BABEL: R :session *R* :exports both :eval always :width 500 :height 500

* Medium scale data processing
Quite a lot of what working biologists do (or could do) with computers
is 'medium scale computing.' I don't know if there's a technical
definition of this, but to me it means that you have too much data for
dealing with in excel, but too little to justify setting up a database
for sophisticated queries. Biological data often comes in batches
(different experimental days) and with lots of covariates (geotype,
environment, person who collected the data). For me the challenge was
learning to quickly get all that data along with it's covariates into
R in a way that was flexible and reusable. That is, my experiments
change all the time, so things can't be too hard-coded, but things
also stay the same and I don't want to have to copy and paste too much.

* What is a list?
When I first started using R, I never bothered much with lists. If I
had three different datasets, they would all be stored as three
different data frames. The problem with this is that you need to
remember what data.frames go together, what their names are, and
what their relationship to each other is. This is where lists come
in. Rather than storing everything as a separate variable, a list has
slots to put conceptually related objects together.

* Making a list by hand							:run:

Directory structure:

- http://people.duke.edu/~csm29/morphology_data
  - definitions_without_stage.csv :: a mapping between morphological
       trait ID and a description of what it is
  - 8 folders (2a1_HAHD, 2a1_HALD, etc.) :: two strains, four media conditions
    - 2a1_HAHD_actin_biological.xls :: morphological measurements for
         actin cytoskeleton
    - 2a1_HAHD_dapi_biological.xls :: morphological measurements for
         nuclear position
    - 2a1_HAHD_conA_biological.xls :: morphological measurements for
         cell wall characteristics

In this case, we'll hand-code a list together that will mimic the
directory structure of our experiment.

#+begin_src R :results output
  baseFile = "http://people.duke.edu/~csm29/morphology_data"
   
  dataTypes = list(
      actin = "_actin_biological.xls",
      dapi = "_dapi_biological.xls",
      conA = "_conA_biological.xls"
      )
  
  samples <- list("2a1_HAHD" = "2a1_HAHD",
                  "2a1_HALD" = "2a1_HALD",
                  "2a1_LALD" = "2a1_LALD",
                  "2a1_LAHD" = "2a1_LAHD",
                  "2b1_HAHD" = "2b1_HAHD",
                  "2b1_HALD" = "2b1_HALD",
                  "2b1_LALD" = "2b1_LALD",
                  "2b1_LAHD" = "2b1_LAHD"
                  )
  
  defs <- read.csv("http://people.duke.edu/~csm29/morphology_data/definitions_without_stage.csv", as.is=T)
  rownames(defs) <- defs$ID
#+end_src

#+results:

* lapply

The simplest function to work with lists is lapply. The thing to
remember about 'apply' functions is that they call a function that you
determine with each successive list item as the first argument of the
function. The clutch thing about 'apply' functions is that they
remember the names of the list items:

** Basic examples

You can instantiate functions as an argument to the lapply
function. This function just returns the exact same variable, which
means our list doesn't change)

#+begin_src R :results output
  lapply( samples[1:4], function(x) x) 
#+end_src

#+results:
#+begin_example
$`2a1_HAHD`
[1] "2a1_HAHD"

$`2a1_HALD`
[1] "2a1_HALD"

$`2a1_LALD`
[1] "2a1_LALD"

$`2a1_LALD`
[1] "2a1_LALD"
#+end_example

Replacing a character in a string with another character

#+begin_src R :results output
  lapply( samples[1:4], function(x) gsub("L", "X", x)) 
#+end_src

#+results:
#+begin_example
$`2a1_HAHD`
[1] "2a1_HAHD"

$`2a1_HALD`
[1] "2a1_HAXD"

$`2a1_LALD`
[1] "2a1_XAXD"

$`2a1_LALD`
[1] "2a1_XAXD"
#+end_example

Splitting a string

strsplit can take vectors and split each string in the vector. There's
no guarantee that the result each string split will be the same
length, so strsplit returns a list. This can be inconvenient when
you're only splitting a single string.

#+begin_src R :results output
  lapply( samples[1:2], strsplit, "_")
#+end_src

#+results:
: $`2a1_HAHD`
: $`2a1_HAHD`[[1]]
: [1] "2a1"  "HAHD"
: 
: 
: $`2a1_HALD`
: $`2a1_HALD`[[1]]
: [1] "2a1"  "HALD"

Using 'str' to visualize a list. You can see that it's depth 2.

#+begin_src R :results output
  str(lapply( samples[1:2], strsplit, "_"))
#+end_src

#+results:
: List of 2
:  $ 2a1_HAHD:List of 1
:   ..$ : chr [1:2] "2a1" "HAHD"
:  $ 2a1_HALD:List of 1
:   ..$ : chr [1:2] "2a1" "HALD"

This example makes a more
complicated function that first splits each string by the underscore,
then returns the first (and only) item in the list, leading to a list
of depth 1.

#+begin_src R :results output
  lapply( samples[1:2], function(x){
      out <- strsplit(x, "_")
      out[[1]]
  })
#+end_src

#+results:
:  $`2a1_HAHD`
: [1] "2a1"  "HAHD"
: 
: $`2a1_HALD`
: [1] "2a1"  "HALD"

* sapply

Depending on the object of the operation, it may be more convenient to
work with the data contained in a list as a data.frame. A function
that facilitates this is 'sapply.' Unlike 'lapply' which always
returns a list, sapply will attempt to make a data.frame out of the
results of lapply. (see the appendix for the relationship between
lists and data.frames).

Since our previous function always returned a result of length 2,
sapply made data.frame with two observations for each of the
columns.

#+begin_src R :results output
  sapply( samples[1:2], function(x){
      out <- strsplit(x, "_")
      out[[1]]
  })
#+end_src

#+results:
:      2a1_HAHD 2a1_HALD
: [1,] "2a1"    "2a1"   
: [2,] "HAHD"   "HALD"

Often, it's convenient to be able to keep track of the 'kind' of
observation that a data point belongs to. The nice thing about sapply
is that by assigning names to the output of the function.

#+begin_src R :results output
  sapply( samples[1:2], function(x){
      out <- strsplit(x, "_")
      out = out[[1]]
      names(out) = c("strain", "media")
      out
  })
#+end_src

#+results:
:        2a1_HAHD 2a1_HALD
: strain "2a1"    "2a1"   
: media  "HAHD"   "HALD"

* Make data paths 

Each folder has three different data types. This function takes three
arguments. The first argument is the folder name, the second is the
'base file', the third is a list of data types. The result of this is
a list where each strain/media has a list that in turn contains a URL
to each data table.

Note that the function takes three arguments. The first argument is
'x' which is the folder name from the list we're going to call it
on. The second two arguments are the base folder and the list of data
types that we defined above. Rather than hard-coding these into the
function, it's better practice to write a function that allows you to
change the value of either the base folder or the data value you want
to read in. lapply allows you to pass such arguments by just appending
them on after the function. This leads to the elegant, but somewhat
difficult to read, function call below:

#+begin_src R :results output
  makeDataPaths <- function(x, bFile, dTypes){
      #Paste together the base of each file
      dataFolder <- paste( bFile, x, x, sep = "/")
      #Paste this base onto each data type
      lapply(dTypes, function(d){
          paste( dataFolder, d, sep = "")
      })
  }
  
  dataPaths <- lapply( samples, makeDataPaths, baseFile, dataTypes)
  
  str(dataPaths[1:2])
#+end_src

#+results:
#+begin_example
List of 2
 $ 2a1_HAHD:List of 3
  ..$ actin: chr "http://people.duke.edu/~csm29/morphology_data/2a1_HAHD/2a1_HAHD_actin_biological.xls"
  ..$ dapi : chr "http://people.duke.edu/~csm29/morphology_data/2a1_HAHD/2a1_HAHD_dapi_biological.xls"
  ..$ conA : chr "http://people.duke.edu/~csm29/morphology_data/2a1_HAHD/2a1_HAHD_conA_biological.xls"
 $ 2a1_HALD:List of 3
  ..$ actin: chr "http://people.duke.edu/~csm29/morphology_data/2a1_HALD/2a1_HALD_actin_biological.xls"
  ..$ dapi : chr "http://people.duke.edu/~csm29/morphology_data/2a1_HALD/2a1_HALD_dapi_biological.xls"
  ..$ conA : chr "http://people.duke.edu/~csm29/morphology_data/2a1_HALD/2a1_HALD_conA_biological.xls"
#+end_example

Since the result of the function is a list and the function was
applied to each element of the list is now a list. An easy way to do
'apply' type operations on a nested list is to call the function
lapply as the second argument to apply. lapply takes two arguments:
the first is a list and the second is the function to apply. Using the
syntax below, we apply lapply to each sub-list, and the function
'print' to each element of the sublist.

#+begin_src R :results output
  foo = lapply( dataPaths[1:2], lapply, print)
#+end_src

#+results:
: [1] "http://people.duke.edu/~csm29/morphology_data/2a1_HAHD/2a1_HAHD_actin_biological.xls"
: [1] "http://people.duke.edu/~csm29/morphology_data/2a1_HAHD/2a1_HAHD_dapi_biological.xls"
: [1] "http://people.duke.edu/~csm29/morphology_data/2a1_HAHD/2a1_HAHD_conA_biological.xls"
: [1] "http://people.duke.edu/~csm29/morphology_data/2a1_HALD/2a1_HALD_actin_biological.xls"
: [1] "http://people.duke.edu/~csm29/morphology_data/2a1_HALD/2a1_HALD_dapi_biological.xls"
: [1] "http://people.duke.edu/~csm29/morphology_data/2a1_HALD/2a1_HALD_conA_biological.xls"

* rapply

If you have many levels of lists, or if the number of levels can
change in the course of your coding, it can be inconvenient to use
lapply to access the elements within the (sub-)(sub-)sub-lists. The
solution is to use 'rapply.' rapply goes recursively (hence the
name) to each (sub-)(sub-)(sub-, etc.)element and then applies the
function. The results can then be returned either as an array or in
the same form as the list was in.

If you specify 'unlist' you wil end up with a character vector:

#+begin_src R :results output
  str(
    rapply( dataPaths[1:2], c, how="unlist")
      )
#+end_src

#+results:
:  Named chr [1:6] "http://people.duke.edu/~csm29/morphology_data/2a1_HAHD/2a1_HAHD_actin_biological.xls" ...
:  - attr(*, "names")= chr [1:6] "2a1_HAHD.actin" "2a1_HAHD.dapi" "2a1_HAHD.conA" "2a1_HALD.actin" ...

Whereas if you specify 'list' you'll end up with a list with the same
number of levels as before.


#+begin_src R :results output
  str(
    rapply( dataPaths[1:2], c, how="list")
      )
#+end_src

#+results:
:  List of 2
:  $ 2a1_HAHD:List of 3
:   ..$ actin: chr "http://people.duke.edu/~csm29/morphology_data/2a1_HAHD/2a1_HAHD_actin_biological.xls"
:   ..$ dapi : chr "http://people.duke.edu/~csm29/morphology_data/2a1_HAHD/2a1_HAHD_dapi_biological.xls"
:   ..$ conA : chr "http://people.duke.edu/~csm29/morphology_data/2a1_HAHD/2a1_HAHD_conA_biological.xls"
:  $ 2a1_HALD:List of 3
:   ..$ actin: chr "http://people.duke.edu/~csm29/morphology_data/2a1_HALD/2a1_HALD_actin_biological.xls"
:   ..$ dapi : chr "http://people.duke.edu/~csm29/morphology_data/2a1_HALD/2a1_HALD_dapi_biological.xls"
:   ..$ conA : chr "http://people.duke.edu/~csm29/morphology_data/2a1_HALD/2a1_HALD_conA_biological.xls"

* Reading in data							:run:

With all this in mind, it's easy to now read in our data. For clarity,
I'm going to reproduce all the code that was needed to get to this
point:

#+begin_src R :results silent
    makeDataPaths <- function(x, bFile, dTypes){
        #Paste together the base of each file
        dataFolder <- paste( bFile, x, x, sep = "/")
        #Paste this base onto each data type
        lapply(dTypes, function(d){
            paste( dataFolder, d, sep = "")
        })
    }
  
  
  baseFile = "http://people.duke.edu/~csm29/morphology_data"
   
  dataTypes = list(
      actin = "_actin_biological.xls",
      dapi = "_dapi_biological.xls",
      conA = "_conA_biological.xls"
      )
  
  samples <- list("2a1_HAHD" = "2a1_HAHD",
                  "2a1_HALD" = "2a1_HALD",
                  "2a1_LALD" = "2a1_LALD",
                  "2a1_LAHD" = "2a1_LAHD",
                  "2b1_HAHD" = "2b1_HAHD",
                  "2b1_HALD" = "2b1_HALD",
                  "2b1_LALD" = "2b1_LALD",
                  "2b1_LAHD" = "2b1_LAHD"
                  )
  
  dataPaths <- lapply( samples, makeDataPaths, baseFile, dataTypes)
  morphList <- rapply( dataPaths, read.table, header = T, sep="\t", how="list")
#+end_src

The result of this is a list of lists. Each strain/media combination
has a list of length three. Each element is a data.frame which
morphological measurements as the columns and cells as the rows. When
we look at the dimensions of these measurements, we can see that each
data type has the same number of cells. In fact, the observations are
in the same order. We make use of this below.

#+begin_src R :results output
  lapply( morphList, sapply, function(x){
      out <- dim(x)
      names(out) <- c("num.cells", "num.vars")
      out
  })[1:2]
#+end_src

#+results:
:  $`2a1_HAHD`
:           actin dapi conA
: num.cells   114  114  114
: num.vars     13  103   25
: 
: $`2a1_HALD`
:           actin dapi conA
: num.cells   109  109  109
: num.vars     13  103   25

* Filtering out bad data						:run:

Since the observations (cells) are in the same order for each data
type, we can simply our list by just gluing together the three
elements in the list.

#+begin_src R :results output
  morphListFiltered <- lapply( morphList, function(x){
      data.frame( x[[1]], x[[2]], x[[3]])
  })
  
  colnames(morphListFiltered[[1]])

#+end_src

#+results:
#+begin_example

  [1] "image_number"   "cell_id"        "Cgroup"         "Agroup"        
  [5] "A101"           "A102"           "A103"           "A104"          
  [9] "A120"           "A121"           "A122"           "A123"          
 [13] "X"              "image_number.1" "cell_id.1"      "Cgroup.1"      
 [17] "Dgroup"         "D101"           "D102"           "D103"          
 [21] "D104"           "D105"           "D106"           "D107"          
 [25] "D108"           "D109"           "D110"           "D111"          
 [29] "D112"           "D113"           "D114"           "D115"          
 [33] "D116"           "D117"           "D118"           "D119"          
 [37] "D120"           "D121"           "D122"           "D123"          
 [41] "D124"           "D125"           "D126"           "D127"          
 [45] "D128"           "D129"           "D130"           "D131"          
 [49] "D132"           "D133"           "D134"           "D135"          
 [53] "D136"           "D137"           "D138"           "D139"          
 [57] "D140"           "D141"           "D142"           "D143"          
 [61] "D144"           "D145"           "D146"           "D147"          
 [65] "D148"           "D149"           "D150"           "D151"          
 [69] "D152"           "D153"           "D154"           "D155"          
 [73] "D156"           "D157"           "D158"           "D159"          
 [77] "D160"           "D161"           "D162"           "D163"          
 [81] "D164"           "D165"           "D166"           "D167"          
 [85] "D168"           "D169"           "D170"           "D171"          
 [89] "D172"           "D173"           "D174"           "D175"          
 [93] "D176"           "D177"           "D178"           "D179"          
 [97] "D180"           "D181"           "D182"           "D183"          
[101] "D184"           "D185"           "D186"           "D187"          
[105] "D188"           "D189"           "D190"           "D191"          
[109] "D192"           "D193"           "D194"           "D195"          
[113] "D196"           "D197"           "D198"           "X.1"           
[117] "image_number.2" "cell_id.2"      "Cgroup.2"       "C101"          
[121] "C102"           "C103"           "C104"           "C105"          
[125] "C106"           "C107"           "C108"           "C109"          
[129] "C110"           "C111"           "C112"           "C113"          
[133] "C114"           "C115"           "C116"           "C117"          
[137] "C118"           "C126"           "C127"           "C128"          
[141] "X.2"
#+end_example

The resulting list contains a bunch of columns, including some
duplicates. Furthermore, not all the data is reliable. We'll exclude
all the crap by wrapping the instructions into one function. We can
then filter all the bad data in a single lapply call.

#+begin_src R :results output
  removeBadData <- function(x){
      out <- subset(x, Cgroup != "complex")
      out <- subset(out, Dgroup != "-")
      out <- subset(out, Agroup != "-")
      unneededColumns <- grep("\\.1|\\.2|X", colnames(out))
      out[,-unneededColumns]
      
  }
  
  morphListFiltered <- lapply( morphListFiltered, removeBadData)
#+end_src

#+results:

* Melting data

The first reshape command we'll look at is 'melt.' The melt function
will take either a list, a data.frame, or a matrix. In the case of a
data.frame, the function will convert from the 'wide' form of data to
the 'long' form of the data. An example will make this easier to understand.

We'll look at just a small subset of the morphological features for a
single strain/media combination

#+begin_src R :results output
  library(reshape)
  
  
  #Restrict the data to a few of the morphological features and some identifying data
  examp <- subset(morphListFiltered[[1]],
                  select = c(image_number, cell_id, Dgroup, C101, C102, C103, C104, C115, C118)
                  )
  
  #This adds information about the cell-cycle phase
  examp$phase <- NA
  examp$phase[ examp$Dgroup == "A" ] <- "G1"
  examp$phase[ examp$Dgroup == "A1" ] <- "S"
  examp$phase[ examp$Dgroup == "C" ] <- "M"
  
  #The restricts the data to only those cells with an identifiable cell cycle phase.
  examp <- subset( examp, !is.na(phase) )
  examp <- subset(examp, select = -Dgroup)
  
  head(examp)
#+end_src

#+results:
#+begin_example

  image_number cell_id C101     C102     C103     C104     C115       C118
1            1       0 1341 135.0538 45.60702 35.60899 1.280773 -1.0000000
2            1       1 2010 167.1960 58.24088 42.72002 1.363316 -1.0000000
3            1       2 1359 136.7107 47.38143 35.35534 1.340149 -1.0000000
4            1       3  879 109.4975 38.58756 28.30194 1.363424 -1.0000000
5            1       4 1526 173.1960 38.94868 32.55764 1.196299  0.4355597
6            1       5 1933 204.4092 46.17359 30.14963 1.531481  0.6779514
  phase
1    G1
2    G1
3    G1
4    G1
5     S
6     S
#+end_example

In the 'wide' form of data, samples have a vector of information
associated with them with each type of data as a column.

To get to the long form of data, we'll call the melt function. In the
'long' form of the data, data types are no longer directly associated
in rows of the data. Rather, each row corresponds to a particular
'data observation' that can keep certain 'indexes' in order to figure
out what individual or observation they correspond to. 
We tell melt which variables we want to keep as
indices (in this case the 'image_number', the 'cell_id', and the
'phase'), and the rest are divided among two columns: a 'variable'
column that tells you the type of data and a 'value' column that tells
you the measurement of the data.

#+begin_src R :results output
  examp.m <- melt(examp, id.vars = c("image_number", "cell_id", "phase"))
  head(examp.m)
#+end_src

#+results:
: 
:   image_number cell_id phase variable value
: 1            1       0    G1     C101  1341
: 2            1       1    G1     C101  2010
: 3            1       2    G1     C101  1359
: 4            1       3    G1     C101   879
: 5            1       4     S     C101  1526
: 6            1       5     S     C101  1933

The variable column contains all the variables that were originally
present as variables in the columns.

#+begin_src R :results output
  unique(examp.m$variable)
#+end_src

#+results:
: [1] C101 C102 C103 C104 C115 C118
: Levels: C101 C102 C103 C104 C115 C118

For your information, this is what the measurements correspond to.

#+begin_src R :results output
  defs[as.character(unique(examp.m$variable)), c("ID","concise_description")]
#+end_src

#+results:
:        ID              concise_description
: C101 C101                  Whole cell size
: C102 C102        Whole cell outline length
: C103 C103  Long axis length in mother cell
: C104 C104 Short axis length in mother cell
: C115 C115                Mother axis ratio
: C118 C118                  Cell size ratio

In some sense, all the morphological measurements are equivalent to
each other. They're all numbers. You can also tell reshape to only
index by the image number and the cell number and not by the phase of
the cell cycle

#+begin_src R :results output
  examp.m2 <- melt(examp, id.vars = c("image_number", "cell_id"))
  head(examp.m2)
#+end_src

#+results:
: 
:   image_number cell_id variable value
: 1            1       0     C101  1341
: 2            1       1     C101  2010
: 3            1       2     C101  1359
: 4            1       3     C101   879
: 5            1       4     C101  1526
: 6            1       5     C101  1933

Cell cycle now appears in the variable column. 

#+begin_src R :results output
  unique(examp.m2$variable)
#+end_src

#+results:
: [1] C101  C102  C103  C104  C115  C118  phase
: Levels: C101 C102 C103 C104 C115 C118 phase

However, this has the unexpected result of converting the value column
to characters. Philosophically, this kind of makes sense. The cell
cycle position is something a little different from the other
measurements, and it's inappropriate to class it with the others.

#+begin_src R :results output
  head(examp.m2$value)
#+end_src

#+results:
: [1] "1341" "2010" "1359" "879"  "1526" "1933"


Depending on the way you want to plot or analyze your data, it makes
sense to have your data in either the long or the short form. For
instance, if you wanted to look at all the variables as difference
plot facets, you would want the data in the long form. You can now
easily assign all the measurement variables to the x axis to make a
series of density plots:

#+begin_src R :results output graphics :file r/file1.png
  ggplot( examp.m, aes(x = value, col=phase))+
      geom_density()+
      facet_wrap(~variable, scale='free')
#+end_src

#+results:
[[file:r/file1.png]]

On the other hand, if you want to look at the relationship between the
types of observations, you'd want to keep the data in the long form:

#+begin_src R :results output graphics :file r/file2.png
  ggplot(examp, aes(x=C103, y=C101, col=phase))+
      geom_point()
#+end_src

#+results:
[[file:r/file2.png]]

Melt can also be used on lists, which is convenient to get our data
out of list form and into something we can work with more easily. 

#+begin_src R :results output
  variablesToKeep = c(
      "image_number",
      "cell_id",
      "C103",
      "C104",
      "C107",
      "C108",
      "C115",
      "C118",
      "C106",
      "D110"
      )
      
  
  morphListFiltered2 <- lapply(morphListFiltered,
                               function(x, y){
                                   out <- x[,c("Dgroup", y)]
                                   out$phase <- NA
                                   out$phase[ out$Dgroup == "A" ] <- "G1"
                                   out$phase[ out$Dgroup == "A1" ] <- "S"
                                   out$phase[ out$Dgroup == "C" ] <- "M"
                                   out <- subset(out, !is.na(phase))
                                   subset(out, select = -Dgroup)
                               }, variablesToKeep)
  
  
  morph <- melt(morphListFiltered2, id.vars = c(variablesToKeep, "phase"))
  
  morph[ morph == -1 ] <- NA
  
  head(morph)
#+end_src

#+results:
#+begin_example

  image_number cell_id     C103     C104     C107     C108     C115      C118
1            1       0 45.60702 35.60899       NA       NA 1.280773        NA
2            1       1 58.24088 42.72002       NA       NA 1.363316        NA
3            1       2 47.38143 35.35534       NA       NA 1.340149        NA
4            1       3 38.58756 28.30194       NA       NA 1.363424        NA
5            1       4 38.94868 32.55764 25.49510 21.94718 1.196299 0.4355597
6            1       5 46.17359 30.14963 34.36568 27.98131 1.531481 0.6779514
       C106     D110 phase       L1
1        NA       NA    G1 2a1_HAHD
2        NA       NA    G1 2a1_HAHD
3        NA       NA    G1 2a1_HAHD
4        NA       NA    G1 2a1_HAHD
5 67.437835 17.80449     S 2a1_HAHD
6  3.396145 11.04536     S 2a1_HAHD
#+end_example

Since we told melt to index based on all the variables, the result is
a long form of the data, except that the data.frame has a variable
corresponding to the element in the list that it came from. This is
convenient for later analysis since the whole point of the list was
that the name of the list was equal to a biological factor in our
analysis.

Alternatively, we can get all our data into a form like we had above
by melting and indexing based on the same index variables we did before.

#+begin_src R :results output
  morph.m <- melt(morphListFiltered2, id.vars = c("image_number", "cell_id", "phase"))
  morph.m$value[ morph.m$value == -1 ] <- NA
  
  head(morph.m)
#+end_src

#+results:
: 
:   image_number cell_id phase variable    value       L1
: 1            1       0    G1     C103 45.60702 2a1_HAHD
: 2            1       1    G1     C103 58.24088 2a1_HAHD
: 3            1       2    G1     C103 47.38143 2a1_HAHD
: 4            1       3    G1     C103 38.58756 2a1_HAHD
: 5            1       4     S     C103 38.94868 2a1_HAHD
: 6            1       5     S     C103 46.17359 2a1_HAHD

Now we've moved from data on a disk in sundry locations to a
convenient pair of data.frames for plotting just about anything. For
example, with a little extra work, we can compare the effect of media on the different
morphological measurements by strain. The following uses strsplit 

#+begin_src R :results silent
  
  #This is a common trick to extract the first place in a underline separated
  #string. strsplit makes a list with a length two character in each place.
  #sapply goes to each element in the list, and gets a particular element
  morph$media <- sapply( strsplit(morph$L1, "_"), "[", 2)
  morph$strain <- sapply( strsplit(morph$L1, "_"), "[", 1)
  
  morph$ammonium <- sapply( strsplit(morph$media, ""), "[", 1)
  morph$dextrose <- sapply( strsplit(morph$media, ""), "[", 3)
  
  morph$ammonium <- factor(morph$ammonium,
                           levels = c("L", "H"),
                           labels = c("50uM ammonium", "5000uM ammonium"))
  
  morph$dextrose <- factor(morph$dextrose,
                           levels = c("H", "L"),
                           labels = c("2% dextrose", "0.5% dextrose"))
  
#+end_src

Now that we have our data in the appropriate form, we can call ggplot
as above, or we could calculate the GxE curves for cell size for each strain!

#+begin_src R :results graphics output :file r/GxE.png
  ggplot(morph, aes(x=strain, y=C103*C104, group = media))+
      stat_summary( fun.data = "mean_cl_boot", geom = "pointrange")+
      stat_summary( fun.y = "mean", geom = "line")+
      facet_grid(ammonium~dextrose)+
      theme_bw()+
      ylab("Rectangular approximation of cell size (pixels)")
#+end_src

#+results:
[[file:r/GxE.png]]


* Casting data

The other half of the reshape package is the 'cast' function. Whereas
melt moves from the wide to the long form of data, cast does the
reverse. Cast requires two arguments. The first is the data that you
want to work with. The second is a formula that tells the function how
to cast the data. The idea is that the data is rewritten into an
array. The axes of the array have various variables assigned to
them. Variables on the same axis are separated by '+' signs, and
variables on different axes are separated by '~' signs. You can have
as many axes as you want. The variables on the first axis are the
rows, the second axis are the columns, the third axis is something
like 'depth', the fourth axis is 'hyperdepth' and so on.

In the formula below we will recast our melted data back into
something like we found it in:

#+begin_src R :results output
  head(cast(morph.m, image_number + cell_id + phase + L1 ~ variable))
#+end_src

#+results:
#+begin_example
  image_number cell_id phase       L1     C103     C104     C107 C108     C115
1            1       0    G1 2a1_HAHD 45.60702 35.60899       NA   NA 1.280773
2            1       0    G1 2a1_HALD 32.28002 29.12044       NA   NA 1.108501
3            1       0    G1 2b1_LAHD 44.29447 30.88689       NA   NA 1.434086
4            1       0     S 2b1_HAHD 54.23099 41.23106 12.04159   NA 1.315295
5            1       1    G1 2a1_HAHD 58.24088 42.72002       NA   NA 1.363316
6            1       1    G1 2b1_HAHD 63.15853 50.15974       NA   NA 1.259148
        C118     C106     D110
1         NA       NA       NA
2         NA       NA       NA
3         NA       NA       NA
4 0.06794521 27.54605 17.46425
5         NA       NA       NA
6         NA       NA       NA
#+end_example

The only difference being that there is a column corresponding to L1
rather than a list. This can be remedied by using the '|' symbol. I'll
print out the first two axes so you can see what's going on:

#+begin_src R :results output
  str(cast(morph.m, image_number + cell_id + phase ~ variable | L1)[1:2])
#+end_src

#+results:
#+begin_example
List of 2
 $ 2a1_HAHD:List of 11
 $ image_number: int [1:103] 1 1 1 1 1 1 2 2 2 2 ...
 $ cell_id     : int [1:103] 0 1 2 3 4 5 7 8 9 10 ...
 $ phase       : chr [1:103] "G1" "G1" "G1" "G1" ...
 $ C103        : num [1:103] 45.6 58.2 47.4 38.6 38.9 ...
 $ C104        : num [1:103] 35.6 42.7 35.4 28.3 32.6 ...
 $ C107        : num [1:103] NA NA NA NA 25.5 ...
 $ C108        : num [1:103] NA NA NA NA 21.9 ...
 $ C115        : num [1:103] 1.28 1.36 1.34 1.36 1.2 ...
 $ C118        : num [1:103] NA NA NA NA 0.436 ...
 $ C106        : num [1:103] NA NA NA NA 67.4 ...
 $ D110        : num [1:103] NA NA NA NA 17.8 ...
 - attr(*, "row.names")= int [1:103] 1 2 3 4 5 6 7 8 9 10 ...
 - attr(*, "idvars")= chr [1:3] "image_number" "cell_id" "phase"
 - attr(*, "rdimnames")=List of 2
  ..$ :'data.frame':	103 obs. of  3 variables:
  .. ..$ image_number: int [1:103] 1 1 1 1 1 1 2 2 2 2 ...
  .. ..$ cell_id     : int [1:103] 0 1 2 3 4 5 7 8 9 10 ...
  .. ..$ phase       : chr [1:103] "G1" "G1" "G1" "G1" ...
  ..$ :'data.frame':	8 obs. of  1 variable:
  .. ..$ variable: Factor w/ 8 levels "C103","C104",..: 1 2 3 4 5 6 7 8
 $ 2a1_HALD:List of 11
 $ image_number: int [1:95] 1 1 1 1 1 2 2 2 2 2 ...
 $ cell_id     : int [1:95] 0 2 4 5 6 7 9 10 11 12 ...
 $ phase       : chr [1:95] "G1" "S" "G1" "S" ...
 $ C103        : num [1:95] 32.3 45.7 44.8 38.9 32.2 ...
 $ C104        : num [1:95] 29.1 41.2 34.5 33.1 30 ...
 $ C107        : num [1:95] NA 23.3 NA 21.6 NA ...
 $ C108        : num [1:95] NA 22.6 NA 20.8 NA ...
 $ C115        : num [1:95] 1.11 1.11 1.3 1.18 1.07 ...
 $ C118        : num [1:95] NA 0.281 NA 0.351 NA ...
 $ C106        : num [1:95] NA 41.34 NA 4.49 NA ...
 $ D110        : num [1:95] NA 15.3 NA 16.3 NA ...
 - attr(*, "row.names")= int [1:95] 1 2 3 4 5 6 7 8 9 10 ...
 - attr(*, "idvars")= chr [1:3] "image_number" "cell_id" "phase"
 - attr(*, "rdimnames")=List of 2
  ..$ :'data.frame':	95 obs. of  3 variables:
  .. ..$ image_number: int [1:95] 1 1 1 1 1 2 2 2 2 2 ...
  .. ..$ cell_id     : int [1:95] 0 2 4 5 6 7 9 10 11 12 ...
  .. ..$ phase       : chr [1:95] "G1" "S" "G1" "S" ...
  ..$ :'data.frame':	8 obs. of  1 variable:
  .. ..$ variable: Factor w/ 8 levels "C103","C104",..: 1 2 3 4 5 6 7 8
 - attr(*, "dim")= int 2
 - attr(*, "dimnames")=List of 1
  ..$ : chr [1:2] "2a1_HAHD" "2a1_HALD"
#+end_example

If you assign a variable to a different axis, reshape will make new
columns corresponding to the different combinations of the variables:

#+begin_src R :results output
  head(cast(morph.m, image_number + cell_id + L1 ~ variable + phase))
#+end_src

#+results:
#+begin_example
  image_number cell_id       L1  C103_G1 C103_M   C103_S  C104_G1 C104_M
1            1       0 2a1_HAHD 45.60702     NA       NA 35.60899     NA
2            1       0 2a1_HALD 32.28002     NA       NA 29.12044     NA
3            1       0 2b1_HAHD       NA     NA 54.23099       NA     NA
4            1       0 2b1_LAHD 44.29447     NA       NA 30.88689     NA
5            1       1 2a1_HAHD 58.24088     NA       NA 42.72002     NA
6            1       1 2b1_HAHD 63.15853     NA       NA 50.15974     NA
    C104_S C107_G1 C107_M   C107_S C108_G1 C108_M C108_S  C115_G1 C115_M
1       NA      NA     NA       NA      NA     NA     NA 1.280773     NA
2       NA      NA     NA       NA      NA     NA     NA 1.108501     NA
3 41.23106      NA     NA 12.04159      NA     NA     NA       NA     NA
4       NA      NA     NA       NA      NA     NA     NA 1.434086     NA
5       NA      NA     NA       NA      NA     NA     NA 1.363316     NA
6       NA      NA     NA       NA      NA     NA     NA 1.259148     NA
    C115_S C118_G1 C118_M     C118_S C106_G1 C106_M   C106_S D110_G1 D110_M
1       NA      NA     NA         NA      NA     NA       NA      NA     NA
2       NA      NA     NA         NA      NA     NA       NA      NA     NA
3 1.315295      NA     NA 0.06794521      NA     NA 27.54605      NA     NA
4       NA      NA     NA         NA      NA     NA       NA      NA     NA
5       NA      NA     NA         NA      NA     NA       NA      NA     NA
6       NA      NA     NA         NA      NA     NA       NA      NA     NA
    D110_S
1       NA
2       NA
3 17.46425
4       NA
5       NA
6       NA
#+end_example

It's all very nice to be able to rewrite your data in lots of
different ways, but the real power of cast comes from its ability to
aggregate lots of different variables. Let's say we dropped out some
of the orignal variables on the first axis:

#+begin_src R :results output
  head(cast(morph.m, phase + L1 ~ variable))
#+end_src

#+results:
: Aggregation requires fun.aggregate: length used as default
:   phase       L1 C103 C104 C107 C108 C115 C118 C106 D110
: 1    G1 2a1_HAHD   61   61   61   61   61   61   61   61
: 2    G1 2a1_HALD   70   70   70   70   70   70   70   70
: 3    G1 2a1_LAHD   56   56   56   56   56   56   56   56
: 4    G1 2a1_LALD   45   45   45   45   45   45   45   45
: 5    G1 2b1_HAHD   32   32   32   32   32   32   32   32
: 6    G1 2b1_HALD   48   48   48   48   48   48   48   48

Cast warns us that there's not a unique combination. This makes sense:
there's lots of different data points that 1) measure C103, 2) are in
phase G1, and 3) belong to experiment '2a1_HAHD'. In fact, there are
61 of them. We can see this by plotting exactly this in ggplot:

#+begin_src R :results output graphics :file r/file3.png
  ggplot(morph.m, aes(x = L1, y = value))+
      geom_point(position = position_jitter(width = 0.1), alpha = 0.2)+
      facet_grid(variable~phase, scale="free")
#+end_src

#+results:
[[file:r/file3.png]]

As a result, if you're not interested in the number of observations
that you have for a particular class of data, you need to supply a
function for cast to aggregate the data with. The argument that this
is specified under is called 'fun.aggregate'. In this case, we'll use
the mean:

#+begin_src R :results output
  head(cast(morph.m, phase + L1 ~ variable, fun.aggregate = "mean"))
#+end_src

#+results:
: 
:   phase       L1     C103     C104 C107 C108     C115 C118 C106 D110
: 1    G1 2a1_HAHD 44.42133 33.63121   NA   NA 1.322337   NA   NA   NA
: 2    G1 2a1_HALD 42.47919 33.38616   NA   NA 1.267637   NA   NA   NA
: 3    G1 2a1_LAHD 39.48546 32.13472   NA   NA 1.230856   NA   NA   NA
: 4    G1 2a1_LALD 38.65069 32.73564   NA   NA 1.184766   NA   NA   NA
: 5    G1 2b1_HAHD 50.80645 40.48347   NA   NA 1.262813   NA   NA   NA
: 6    G1 2b1_HALD 42.90138 35.51088   NA   NA 1.212462   NA   NA   NA

This is equivalent to just looking at the mean of each variable for
each phase and media condition. You can also plot this using
ggplot. If this looks familiar, it should. Much of the same syntax is
used. Rather than assigning variables (L1, variable, phase) to
different axes of a table, they're assigned to different graphical
aspects of the plot. In the case of ggplot stat_summary takes the
place of fun.aggreate to compute some sort of summary statistic that
is plotted as a point.

#+begin_src R :results output graphics :file r/file4.png
  ggplot(morph.m, aes(x = L1, y = value))+
      stat_summary(fun.y="mean", geom = "point")+
      facet_grid(variable~phase, scale="free")
#+end_src

#+results:
[[file:r/file4.png]]

In fact, we could skip the stat_summary call and just call 'point' if
we did the calculations beforehand ourselves. However, we need to cast
the data into a slightly different form:

#+begin_src R :results output
  morph.c <- cast(morph.m, phase + L1 + variable ~ . , fun.aggregate = "mean")
  colnames(morph.c)[4] <- "value"
  head(morph.c)
#+end_src 

#+results:
: 
:   phase       L1 variable     value
: 1    G1 2a1_HAHD     C103 44.421334
: 2    G1 2a1_HAHD     C104 33.631213
: 3    G1 2a1_HAHD     C107        NA
: 4    G1 2a1_HAHD     C108        NA
: 5    G1 2a1_HAHD     C115  1.322337
: 6    G1 2a1_HAHD     C118        NA

However, once cast has operated, the results are identical:

#+begin_src R :results output graphics :file r/file5.png
  ggplot(morph.c, aes(x = L1, y = value))+
      geom_point()+
      facet_grid(variable~phase, scale="free")
#+end_src

#+results:
[[file:r/file5.png]]


This isn't really the most useful summary. It might be better to write
something more like this:

#+begin_src R :results output
  morph.m$media <- sapply( strsplit(morph.m$L1, "_"), "[", 2)
  morph.m$strain <- sapply( strsplit(morph.m$L1, "_"), "[", 1)
  cast(morph.m, strain + phase ~ media | variable, fun.aggregate = "mean")[1:3]
#+end_src

#+results:
: Error: Casting formula contains variables not found in molten data: strain, media




* plyr the split, apply, combine paradigm
** ddply
** dlply
** ldply
** ddply for reading in complex data
* Melting your data into a form usable by ggplot
* Casting your data to plot summary statistics
* Casting your data for subsequent filtering
* How to deal with obnoxious data
- Example using Tecan output and scan

* Appendix
** [[ vs [

There are two functions to index list items: '[' and '[['. It might
seem funny to have these symbols called 'functions', but that's
exactly what they are stored as in R. If you just type in '[' to the
command line, you'll get an error, but if you put the brackets in the
funny backwards quote marks, this tells R that you want to look at
what the function means rather than calling it:

#+begin_src R :results output
  `[`
#+end_src

#+results:
: .Primitive("[")

In fact, you can use the backwards quotes to see what the function
does. It's first argument is a list, it's second argument can be
either an integer or a string. What it does is return the list element
that has either the name of the string or the index of the
integer. Importantly, it returns the results as a list.

#+begin_src R :results output
  `[`(samples, 1)
  `[`(samples, "2a1_HAHD")
#+end_src

#+results:
: $`2a1_HAHD`
: [1] "2a1_HAHD"
: $`2a1_HAHD`
: [1] "2a1_HAHD"

The usual way you use this function is more familiar:

#+begin_src R :results output
samples[1]
samples["2a1_HAHD"]
#+end_src

#+results:
: $`2a1_HAHD`
: [1] "2a1_HAHD"
: $`2a1_HAHD`
: [1] "2a1_HAHD"

You can use '[' to return more than one item in a list:

#+begin_src R :results output
samples[1:3]
print("")
samples[c("2a1_HAHD","2a1_HALD", "2a1_LALD")]
#+end_src

#+results:
#+begin_example
$`2a1_HAHD`
[1] "2a1_HAHD"

$`2a1_HALD`
[1] "2a1_HALD"

$`2a1_LALD`
[1] "2a1_LALD"
[1] ""
$`2a1_HAHD`
[1] "2a1_HAHD"

$`2a1_HALD`
[1] "2a1_HALD"

$`2a1_LALD`
[1] "2a1_LALD"
#+end_example

The second way to index lists is similar, but rather than returning a
list, it returns the value of the list item

#+begin_src R :results output
samples[[1]]
samples[["2a1_HAHD"]]
#+end_src

#+results:
: [1] "2a1_HAHD"
: [1] "2a1_HAHD"

You can't return more than one item like this:

#+begin_src R :results output
samples[[1:3]]
#+end_src

#+results:
: Error in samples[[1:3]] : recursive indexing failed at level 2

** The relationship between data.frames and lists

#+begin_src R :results output
  
  list1 <- list(
      column1 = 1:5,
      column2 = c("A", "B", "C", "D", "E")
      )
  
  str(list1)
  
  as.data.frame(list1)
  
  names(list1[[1]]) <- c("sally", "betty", "irene", "bob", "bobby")
  
  as.data.frame(list1)
  
  names(list1[[2]]) <- c("sally", "betty", "irene", "bob", "bobby.jean")
  
  as.data.frame(list1)
  
  
  list2 <- list(
      column1 = 1:5,
      column2 = c("A", "B", "C", "D", "E", "F")
      )
  
  as.data.frame(list2)
  
  df1 <- as.data.frame(list1)
  
  str(df1)
  str(list1)
  
  df1[[1]]
  
  df1[[3]] <- c("red", "red", "blue", "blue", "blue")
  
  str(df1)
  
  df1 <- df1[-3]
  
  str(df1)
  
  df1$car.color <- c("red", "red", "blue", "blue", "blue")
  
  str(df1)
#+end_src

